4.36 (shell-1). Напомним, что программа, которая ведёт с пользователем диалог, обеспечивая нам возможность управления командным потоком; командный строковый, называемый командным интерпретатором. (Чрезвычайно важно попробовать написать свой собственный (конечно, упрощённый) командный интерпретатор – такую программу, которая будет в цикле читать из потока стандартного ввода строки, вводимые пользователем, и, проанализировав очередную строку, выполнять её в качестве команды – в большинстве случаев это означает что нужно запустить некую внешнюю программу с заданными параметрами командной строки и дождаться её завершения. Большая часть сведений, которые для этого
потребуются, изложена в пятой части «Введения в профессию», так что основную часть командного интерпретатора мы оставим до следующей части нашего задачника; но командный интерпретатор программа довольно сложная, и её создание правильнее разбить на отдельные этапы, к первому из которых вы уже, можно надеяться, готовы.
Первый этап подразумевает только чтение и анализ строк; иначе говоря, программа должна всё подготовить, чтобы можно было выполнить команды, но сами команды пока не запускать, поскольку мы этого ещё не умеем. Что до анализа строки, то фактически ей нужно разбить на слова, используя символы пробела и табуляции как разделительные. Единственное что тут состоит в том, как в слово тоже бывают пробелы, и настоящий командный интерпретатор, такой как привычный нам bash, предусматривает несколько разных способов такие пробелы в слова вставлять; из всех этих способов мы задействуем только двойные кавычки: внутри кавычек и пробел и табуляция должны восприниматься как простые символы, не отделяющие слова друг от друга. Нечетное количество кавычек в строке должно рассматриваться как ошибка: после выдачи пользователю соответствующего сообщения нужно очистить всю занятую динамическую память и продолжить работу (!). Запомните: ведь настоящий shell не завершает свою работы из-за каждой ошибки пользователя! Вообще завершать работу ваш командный интерпретатор должен только в одном случае: если в потоке стандартного ввода возникла ситуация «конец файла». Во всех остальных случаях следует продолжать чтение строк.
Учтите, что символ кавычки может встретиться где угодно, в том числе в середине слова; сам он в слова не входит, он просто переключает режим анализа: воспринимать ли пробелы и табуляции как разделители (обычный режим) или как простые символы (режим внутри кавычек).
Прочитав строку из стандартного потока ввода, ваша программа должна сформировать список строк, элементы которого будут содержать слова, сформированные в ходе анализа. Список следует построить из элементов, содержащих указатель на строку (имеющий тип char*) и указатель на следующий элемент списка:

struct word_item {
    char *word;
    struct word_item *next;
};

В таком виде введенная пользователем команда практически готова к выполнению, но, поскольку мы еще не знаем, как её приготовить,
поступим проще: напечатаем полученные слова (каждое на отдельной строке; будет лучше, если каждое слово мы на печати на всякий случай возьмём в квадратные скобки, чтобы было видно, если вдруг у нас в словах окажутся ненужные пробелы), затем освободим всю захваченную динамическую память и продолжим работу, то есть приступим к чтению следующей строки.
Перед вводом очередной строки выдайте какое-нибудь приглашение к вводу, например, символ >> и пробел. Работа с вашей программой должна в итоге выглядеть примерно так:
user@host:~$ ./shell1
> abra schwabra kadabra
[abra]
[schwabra]
[kadabra]
> abra schwabra kadabra
[abra]
[schwabra]
[kadabra]
> abra "schwabra kadabra" "foo bar"
[abra]
[schwabra kadabra]
[foo bar]
> abra schw"abra ka"dab"ra" foo" "bar
[abra]
[schwabra kadabra]
[foo bar]
> abra schwabra kadabra" foo bar
Error: unclosed quotes
> abrashwabrakadabra
[abrashwabrakadabra]
> ^D
user@host:~$

Обязательно проверьте свою программу на утечки памяти! Для этого откройте два терминальных окна так, чтобы можно было видеть их оба одновременно; в одном из них запустите программу top. Переключившись в другое окно, запустите там вашу программу в составе примерно такого конвейера (обратите внимание на апострофы!):
yes 'abra schw"abra ka"dab"ra" foo" "bar' | ./shell1 > /dev/null
Сразу после этого ваша программа (в нашем примере её исполняемый файл называется shell1) появится в верхних строчках topа, выдаваемого программой top в соседнем окне; подождите несколько секунд, и если за это время числа, показывающие количество занимаемой вашей программой памяти (в особенности число в колонке VIRT), не начнут плавно расти, то всё, скорее всего, в порядке; если же они действительно стали расти, немедленно прибейте ваш конвейер нажатием Ctrl-C (иначе ваша программа запросто может сожрать всю доступную память и «повесить» систему) и приступайте к поиску – где-то в вашей программе память выделяется, но не освобождается.
4.37. Доработайте решение задачи 4.36 так, чтобы в слово можно было включить символ двойной кавычки. Для этого предусмотрите ещё один «специальный» символ – \, который будет «экранировать» символ, стоящий следом за ним; таких «экранируемых» символов следует предусмотреть два: символ двойной кавычки и сам символ \, ведь его тоже может потребоваться ввести в слово. Как реагировать, если следом за \ в строке располагается какой-то ещё символ – придумайте сами, только не завершайте при этом работу программы (увы, приходится об этом напоминать).
4.38. Снабдите решение задачи 4.36 возможность сформировать пустое слово. Обозначением пустого слова считайте два символа двойных кавычек, встреченные подряд вне слов, то есть когда накопленное слово пусто, а сразу после закрывающей кавычки идёт либо пробельный символ, либо конец строки.
