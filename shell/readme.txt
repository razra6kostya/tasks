4.36 (shell-1). Напомним, что программа, которая ведёт с пользователем диалог, обеспечивая нам возможность управления командным потоком; командный строковый, называемый командным интерпретатором. (Чрезвычайно важно попробовать написать свой собственный (конечно, упрощённый) командный интерпретатор – такую программу, которая будет в цикле читать из потока стандартного ввода строки, вводимые пользователем, и, проанализировав очередную строку, выполнять её в качестве команды – в большинстве случаев это означает что нужно запустить некую внешнюю программу с заданными параметрами командной строки и дождаться её завершения. Большая часть сведений, которые для этого
потребуются, изложена в пятой части «Введения в профессию», так что основную часть командного интерпретатора мы оставим до следующей части нашего задачника; но командный интерпретатор программа довольно сложная, и её создание правильнее разбить на отдельные этапы, к первому из которых вы уже, можно надеяться, готовы.
Первый этап подразумевает только чтение и анализ строк; иначе говоря, программа должна всё подготовить, чтобы можно было выполнить команды, но сами команды пока не запускать, поскольку мы этого ещё не умеем. Что до анализа строки, то фактически ей нужно разбить на слова, используя символы пробела и табуляции как разделительные. Единственное что тут состоит в том, как в слово тоже бывают пробелы, и настоящий командный интерпретатор, такой как привычный нам bash, предусматривает несколько разных способов такие пробелы в слова вставлять; из всех этих способов мы задействуем только двойные кавычки: внутри кавычек и пробел и табуляция должны восприниматься как простые символы, не отделяющие слова друг от друга. Нечетное количество кавычек в строке должно рассматриваться как ошибка: после выдачи пользователю соответствующего сообщения нужно очистить всю занятую динамическую память и продолжить работу (!). Запомните: ведь настоящий shell не завершает свою работы из-за каждой ошибки пользователя! Вообще завершать работу ваш командный интерпретатор должен только в одном случае: если в потоке стандартного ввода возникла ситуация «конец файла». Во всех остальных случаях следует продолжать чтение строк.
Учтите, что символ кавычки может встретиться где угодно, в том числе в середине слова; сам он в слова не входит, он просто переключает режим анализа: воспринимать ли пробелы и табуляции как разделители (обычный режим) или как простые символы (режим внутри кавычек).
Прочитав строку из стандартного потока ввода, ваша программа должна сформировать список строк, элементы которого будут содержать слова, сформированные в ходе анализа. Список следует построить из элементов, содержащих указатель на строку (имеющий тип char*) и указатель на следующий элемент списка:

struct word_item {
    char *word;
    struct word_item *next;
};

В таком виде введенная пользователем команда практически готова к выполнению, но, поскольку мы еще не знаем, как её приготовить,
поступим проще: напечатаем полученные слова (каждое на отдельной строке; будет лучше, если каждое слово мы на печати на всякий случай возьмём в квадратные скобки, чтобы было видно, если вдруг у нас в словах окажутся ненужные пробелы), затем освободим всю захваченную динамическую память и продолжим работу, то есть приступим к чтению следующей строки.
Перед вводом очередной строки выдайте какое-нибудь приглашение к вводу, например, символ >> и пробел. Работа с вашей программой должна в итоге выглядеть примерно так:
user@host:~$ ./shell1
> abra schwabra kadabra
[abra]
[schwabra]
[kadabra]
> abra schwabra kadabra
[abra]
[schwabra]
[kadabra]
> abra "schwabra kadabra" "foo bar"
[abra]
[schwabra kadabra]
[foo bar]
> abra schw"abra ka"dab"ra" foo" "bar
[abra]
[schwabra kadabra]
[foo bar]
> abra schwabra kadabra" foo bar
Error: unclosed quotes
> abrashwabrakadabra
[abrashwabrakadabra]
> ^D
user@host:~$

Обязательно проверьте свою программу на утечки памяти! Для этого откройте два терминальных окна так, чтобы можно было видеть их оба одновременно; в одном из них запустите программу top. Переключившись в другое окно, запустите там вашу программу в составе примерно такого конвейера (обратите внимание на апострофы!):
yes 'abra schw"abra ka"dab"ra" foo" "bar' | ./shell1 > /dev/null
Сразу после этого ваша программа (в нашем примере её исполняемый файл называется shell1) появится в верхних строчках topа, выдаваемого программой top в соседнем окне; подождите несколько секунд, и если за это время числа, показывающие количество занимаемой вашей программой памяти (в особенности число в колонке VIRT), не начнут плавно расти, то всё, скорее всего, в порядке; если же они действительно стали расти, немедленно прибейте ваш конвейер нажатием Ctrl-C (иначе ваша программа запросто может сожрать всю доступную память и «повесить» систему) и приступайте к поиску – где-то в вашей программе память выделяется, но не освобождается.

4.37. Доработайте решение задачи 4.36 так, чтобы в слово можно было включить символ двойной кавычки. Для этого предусмотрите ещё один «специальный» символ – \, который будет «экранировать» символ, стоящий следом за ним; таких «экранируемых» символов следует предусмотреть два: символ двойной кавычки и сам символ \, ведь его тоже может потребоваться ввести в слово. Как реагировать, если следом за \ в строке располагается какой-то ещё символ – придумайте сами, только не завершайте при этом работу программы (увы, приходится об этом напоминать).

4.38. Снабдите решение задачи 4.36 возможность сформировать пустое слово. Обозначением пустого слова считайте два символа двойных кавычек, встреченные подряд вне слов, то есть когда накопленное слово пусто, а сразу после закрывающей кавычки идёт либо пробельный символ, либо конец строки.

5.15 (shell-II). Вернитесь к программе, которую вы писали, и модифицируйте её так, чтобы введённые пользователем команды не печатались, а выполнялись, то есть чтобы ваша программа, прочитав очередную команду, запускала внешнюю программу, имя которой задано первым словом, а остальные слова представляют собой аргументы командной строки.
Поскольку процесс в ОС Unix не может изменить текущую директорию другому процессу, а только команду cd (то есть буквально – ситуация, когда первое слово введённой команды состоит из двух символов – «c» и «d») придётся рассматривать как особый случай. Запуск внешней программы здесь бесполезен; вместо этого проверьте, что задан ровно один параметр (т.е. введённая команда состоит ровно из двух слов: собственно «cd» и имени директории), и смените текущую директорию с помощью системного вызова chdir.

5.16. Доработайте программу, написанную при решении предыдущей задачи, так, чтобы команду cd можно было дать без параметров, и при этом, как и в «настоящем» командном интерпретаторе, устанавливала в качестве текущей домашнюю директорию пользователя.

5.17 (shell-III). Когда речь идёт о разборе текста на формальном языке, в большинстве случаев первой стадией такого разбора становится лексический анализ, то есть разбиение текста на лексемы или токены; решение задачи 4.36 можно рассматривать как простейший лексический анализатор, а токенами здесь выступают те самые слова, на которые наша программа делит введённую пользователем строку.
В языках программирования некоторые символы или определённые последовательности символов (как правило, короткие – в два символа, очень редко в три) выделяются в отдельные лексемы, даже если их не отделяет от остального текста пробелами. Таковы обычно всевозможные скобки, пунктуационные символы вроде ;, :, ,, | или ::; обозначения арифметических операций – такие как +, -, /, * и т. п. Примерами разделителей, состоящих более чем из одного символа, служат обозначения некоторых операций языка Си: +=, &&, ->, а, скажем, == и >= – это тот самый редкий случай разделителя из трёх символов. Отметим, что обозначения операций не обязаны быть разделителями: так, в Паскале слова div, mod, and, or или not разделителями не являются; ведь если написать, к примеру, aandb – это будет совсем не то же самое, что a and b (тогда как в Си a&&b и a & & b – совершенно одно и то же, поскольку здесь конъюнкция обозначена разделителем &&). 
уществуют свои разделители и во входном языке командного интерпретатора. В нашем упрощённом интерпретаторе можно ограничиться небольшим количеством разделителей, но совсем без них обойтись невозможно.
Начнём мы с того, что снабдим наш командный интерпретатор возможностью запуска процесса в фоновом режиме, а для этого нам потребуется символ & (амперсанд), и его нужно оформить как разделитель. Говоря более конкретно, нужно, чтобы ваша программа, встретив этот символ вне кавычек, рассматривала его как «отдельное слово» вне всякой зависимости от того, есть вокруг него пробелы или нет; причём это должно быть некое «хитрое» слово, отличающееся от простого слова из одного амперсанда (такое можно получить, если заключить амперсанд в кавычки, а вокруг кавычек поставить пробелы).
Амперсанд означает, что команду следует выполнить «в фоновом режиме», то есть, попросту говоря, не ждать её завершения — запустить и «забыть», продолжая читать команды с клавиатуры и выполнять их. Нужно будет только не забыть вовремя убрать зомби, когда такая фоновая команда всё-таки завершится. Настоящие командные интерпретаторы позволяют ввести сразу несколько команд, разделив их амперсандами, при этом все команды, кроме последней, будут выполняться в фоновом режиме; но эта возможность всё равно применяется очень редко, так что мы поступим проще: будем считать, что амперсанд должен располагаться в конце строки, т.е. если после него есть ещё что-то, кроме пробелов, будем выдавать ошибку.
Если пользователь ввёл всё правильно, то есть амперсанд, встреченный вне кавычек, является в строке последним значащим символом, то ваша программа должна введённую команду исполнить как фоновую (сам амперсанд, конечно, в такую команду не входит, используется только настоящие слова, расположенные до него). Само по себе это даже проще, чем обычное выполнение — просто не делать wait, и всё; но сам факт возможности существования фоновых процессов означает, что выполнение команд в обычном режиме, не фоновом, становится несколько сложнее, хотя и не сильно. Попробуйте сами сообразить, в чём тут проблема и как с ней справиться, если же сразу не догадаетесь — воспользуйтесь указаниями на стр. 133.
В настоящий случай отметим, что в последующих задачах посвящёных командному интерпретатору, потребуются ещё разделители >, <, >>, |, ;, (, ) && ||. И если вы планируете довести эту программу до конца – возможно, имеет смысл предусмотреть все разделительные лексемы прямо сейчас, вместе с одиночным амперсандом, чтобы больше не переделывать ваш анализатор строки; пока соответствующие возможности не реализованы, при появлении в пользовательском вводе любого из этих разделителей следует фиксировать ошибку с диагностикой вроде «Feature not implemented yet».
